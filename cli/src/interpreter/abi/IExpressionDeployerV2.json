{
  "abi": [
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "deployer",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "interpreter",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "store",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "meta",
          "type": "bytes"
        }
      ],
      "name": "DISpair",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "bytecode",
          "type": "bytes"
        },
        {
          "internalType": "uint256[]",
          "name": "constants",
          "type": "uint256[]"
        },
        {
          "internalType": "uint256[]",
          "name": "minOutputs",
          "type": "uint256[]"
        }
      ],
      "name": "deployExpression",
      "outputs": [
        {
          "internalType": "contract IInterpreterV1",
          "name": "interpreter",
          "type": "address"
        },
        {
          "internalType": "contract IInterpreterStoreV1",
          "name": "store",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "expression",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "bytecode": {
    "object": "0x",
    "sourceMap": "",
    "linkReferences": {}
  },
  "deployedBytecode": {
    "object": "0x",
    "sourceMap": "",
    "linkReferences": {}
  },
  "methodIdentifiers": {
    "deployExpression(bytes,uint256[],uint256[])": "31a66b65"
  },
  "rawMetadata": "{\"compiler\":{\"version\":\"0.8.19+commit.7dd6d404\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"deployer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"interpreter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"store\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"meta\",\"type\":\"bytes\"}],\"name\":\"DISpair\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"bytecode\",\"type\":\"bytes\"},{\"internalType\":\"uint256[]\",\"name\":\"constants\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"minOutputs\",\"type\":\"uint256[]\"}],\"name\":\"deployExpression\",\"outputs\":[{\"internalType\":\"contract IInterpreterV1\",\"name\":\"interpreter\",\"type\":\"address\"},{\"internalType\":\"contract IInterpreterStoreV1\",\"name\":\"store\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"expression\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"events\":{\"DISpair(address,address,address,address,bytes)\":{\"params\":{\"meta\":\"The raw binary data of the construction meta. Maybe compressed data etc. and is intended for offchain consumption.\",\"sender\":\"The `msg.sender` providing the op meta.\"}}},\"kind\":\"dev\",\"methods\":{\"deployExpression(bytes,uint256[],uint256[])\":{\"params\":{\"bytecode\":\"Bytecode verbatim. Exactly how the bytecode is structured is up to the deployer and interpreter. The deployer MUST NOT modify the bytecode in any way. The interpreter MUST NOT assume anything about the bytecode other than that it is valid according to the interpreter's integrity checks. It is assumed that the bytecode will be produced from a human friendly string via. `IParserV1.parse` but this is not required if the caller has some other means to prooduce valid bytecode.\",\"constants\":\"Constants verbatim. Constants are provided alongside sources rather than inline as it allows us to avoid variable length opcodes and can be more memory efficient if the same constant is referenced several times from the sources.\",\"minOutputs\":\"The first N sources on the state config are entrypoints to the expression where N is the length of the `minOutputs` array. Each item in the `minOutputs` array specifies the number of outputs that MUST be present on the final stack for an evaluation of each entrypoint. The minimum output for some entrypoint MAY be zero if the expectation is that the expression only applies checks and error logic. Non-entrypoint sources MUST NOT have a minimum outputs length specified.\"},\"returns\":{\"expression\":\"The address of the deployed onchain expression. MUST be valid according to all integrity checks the deployer is aware of.\",\"interpreter\":\"The interpreter the deployer believes it is qualified to perform integrity checks on behalf of.\",\"store\":\"The interpreter store the deployer believes is compatible with the interpreter.\"}}},\"title\":\"IExpressionDeployerV2\",\"version\":1},\"userdoc\":{\"events\":{\"DISpair(address,address,address,address,bytes)\":{\"notice\":\"This is the literal InterpreterOpMeta bytes to be used offchain to make sense of the opcodes in this interpreter deployment, as a human. For formats like json that make heavy use of boilerplate, repetition and whitespace, some kind of compression is recommended.\"}},\"kind\":\"user\",\"methods\":{\"deployExpression(bytes,uint256[],uint256[])\":{\"notice\":\"Expressions are expected to be deployed onchain as immutable contract code with a first class address like any other contract or account. Technically this is optional in the sense that all the tools required to eval some expression and define all its opcodes are available as libraries. In practise there are enough advantages to deploying the sources directly onchain as contract data and loading them from the interpreter at eval: - Loading and storing binary data is gas efficient as immutable contract   data - Expressions need to be immutable between their deploy time integrity   check and runtime evaluation - Passing the address of an expression through calldata to an interpreter   is cheaper than passing an entire expression through calldata - Conceptually a very simple approach, even if implementations like   SSTORE2 are subtle under the hood The expression deployer MUST perform an integrity check of the source code before it puts the expression onchain at a known address. The integrity check MUST at a minimum (it is free to do additional static analysis) calculate the memory required to be allocated for the stack in total, and that no out of bounds memory reads/writes occur within this stack. A simple example of an invalid source would be one that pushes one value to the stack then attempts to pops two values, clearly we cannot remove more values than we added. The `IExpressionDeployerV2` MUST revert in the case of any integrity failure, all integrity checks MUST pass in order for the deployment to complete. Once the integrity check is complete the `IExpressionDeployerV2` MUST do any additional processing required by its paired interpreter. For example, the `IExpressionDeployerV2` MAY NEED to replace the indexed opcodes in the `ExpressionConfig` sources with real function pointers from the corresponding interpreter.\"}},\"notice\":\"Companion to `IInterpreterV1` responsible for onchain static code analysis and deploying expressions. Each `IExpressionDeployerV2` is tightly coupled at the bytecode level to some interpreter that it knows how to analyse and deploy expressions for. The expression deployer can perform an integrity check \\\"dry run\\\" of candidate source code for the intepreter. The critical analysis/transformation includes: - Enforcement of no out of bounds memory reads/writes - Calculation of memory required to eval the stack with a single allocation - Replacing index based opcodes with absolute interpreter function pointers - Enforcement that all opcodes and operands used exist and are valid This analysis is highly sensitive to the specific implementation and position of all opcodes and function pointers as compiled into the interpreter. This is what makes the coupling between an interpreter and expression deployer so tight. Ideally all responsibilities would be handled by a single contract but this introduces code size issues quickly by roughly doubling the compiled logic of each opcode (half for the integrity check and half for evaluation). Interpreters MUST assume that expression deployers are malicious and fail gracefully if the integrity check is corrupt/bypassed and/or function pointers are incorrect, etc. i.e. the interpreter MUST always return a stack from `eval` in a read only way or error. I.e. it is the expression deployer's responsibility to do everything it can to prevent undefined behaviour in the interpreter, and the interpreter's responsibility to handle the expression deployer completely failing to do so.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"lib/rain.interpreter/src/interface/IExpressionDeployerV2.sol\":\"IExpressionDeployerV2\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"appendCBOR\":false,\"bytecodeHash\":\"none\"},\"optimizer\":{\"enabled\":true,\"runs\":1000000},\"remappings\":[\":@prb/test/=lib/rain.interpreter/lib/prb-math/lib/prb-test/src/\",\":bitwise/=lib/rain.interpreter/src/lib/bitwise/\",\":bytecode/=lib/rain.interpreter/src/lib/bytecode/\",\":caller/=lib/rain.interpreter/src/lib/caller/\",\":compile/=lib/rain.interpreter/src/lib/compile/\",\":ds-test/=lib/forge-std/lib/ds-test/src/\",\":erc4626-tests/=lib/rain.interpreter/lib/openzeppelin-contracts/lib/erc4626-tests/\",\":eval/=lib/rain.interpreter/src/lib/eval/\",\":extern/=lib/rain.interpreter/src/lib/extern/\",\":forge-std/=lib/forge-std/src/\",\":integrity/=lib/rain.interpreter/src/lib/integrity/\",\":ns/=lib/rain.interpreter/src/lib/ns/\",\":op/=lib/rain.interpreter/src/lib/op/\",\":openzeppelin-contracts/=lib/rain.interpreter/lib/openzeppelin-contracts/\",\":openzeppelin/=lib/rain.interpreter/lib/openzeppelin-contracts/contracts/\",\":parse/=lib/rain.interpreter/src/lib/parse/\",\":prb-math/=lib/rain.interpreter/lib/prb-math/src/\",\":prb-test/=lib/rain.interpreter/lib/prb-math/lib/prb-test/src/\",\":rain.chainlink/=lib/rain.interpreter/lib/rain.chainlink/src/\",\":rain.datacontract/=lib/rain.interpreter/lib/rain.datacontract/src/\",\":rain.erc1820/=lib/rain.interpreter/lib/rain.erc1820/src/\",\":rain.interpreter/=lib/rain.interpreter/\",\":rain.lib.hash/=lib/rain.interpreter/lib/rain.lib.memkv/lib/rain.lib.hash/src/\",\":rain.lib.memkv/=lib/rain.interpreter/lib/rain.lib.memkv/src/\",\":rain.lib.typecast/=lib/rain.interpreter/lib/rain.lib.typecast/src/\",\":rain.math.fixedpoint/=lib/rain.interpreter/lib/rain.math.fixedpoint/src/\",\":rain.math.saturating/=lib/rain.interpreter/lib/rain.math.fixedpoint/lib/rain.math.saturating/src/\",\":rain.metadata/=lib/rain.interpreter/lib/rain.metadata/src/\",\":rain.solmem/=lib/rain.interpreter/lib/rain.solmem/src/\",\":sol.lib.binmaskflag/=lib/rain.interpreter/lib/sol.lib.binmaskflag/src/\",\":state/=lib/rain.interpreter/src/lib/state/\",\":uniswap/=lib/rain.interpreter/src/lib/uniswap/\",\":v2-core/=lib/rain.interpreter/lib/v2-core/contracts/\",\":v2-periphery/=lib/rain.interpreter/lib/v2-periphery/contracts/\"]},\"sources\":{\"lib/rain.interpreter/src/interface/IExpressionDeployerV2.sol\":{\"keccak256\":\"0x2b8e9d48c92c2c0e874fb4d073b0cb013fb36a830e16c68657bcf65ede7d8b16\",\"license\":\"CAL\",\"urls\":[\"bzz-raw://8de383c71dcaabb32fd9b91912bc7cba001a5a89c6f5de08b1a92447d0bebd12\",\"dweb:/ipfs/QmV1JV5ctH9cktJbYJxXvBNBePshfVB58voEUMCbgCtkhj\"]},\"lib/rain.interpreter/src/interface/IInterpreterStoreV1.sol\":{\"keccak256\":\"0xbd9baa8cd30406576f876a76f1c08396561ba93131741af338f63e2414e20619\",\"license\":\"CAL\",\"urls\":[\"bzz-raw://30bb6f09d8b8f27f77e6c44591c4f2070286a91dad202043cf2351ae802e3df5\",\"dweb:/ipfs/QmRz5pfzf5w84iNmKaYYbqP8oQywzc5xbd3xzKmxgFyf9y\"]},\"lib/rain.interpreter/src/interface/IInterpreterV1.sol\":{\"keccak256\":\"0xebde08ca2e1c25fc733e0bb8867598715f8ba79772f86db1c8960ad7d68a5293\",\"license\":\"CAL\",\"urls\":[\"bzz-raw://b93fb28a09aeea4afe7f0d4afc67354c0fa538e5a9b274b0c5f10ed1dd6b6b00\",\"dweb:/ipfs/QmatNhoHRSJ1ZvoCNo61YMt9jb1vvEkWy3mkcoPkB4FFA9\"]}},\"version\":1}",
  "metadata": {
    "compiler": {
      "version": "0.8.19+commit.7dd6d404"
    },
    "language": "Solidity",
    "output": {
      "abi": [
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "sender",
              "type": "address",
              "indexed": false
            },
            {
              "internalType": "address",
              "name": "deployer",
              "type": "address",
              "indexed": false
            },
            {
              "internalType": "address",
              "name": "interpreter",
              "type": "address",
              "indexed": false
            },
            {
              "internalType": "address",
              "name": "store",
              "type": "address",
              "indexed": false
            },
            {
              "internalType": "bytes",
              "name": "meta",
              "type": "bytes",
              "indexed": false
            }
          ],
          "type": "event",
          "name": "DISpair",
          "anonymous": false
        },
        {
          "inputs": [
            {
              "internalType": "bytes",
              "name": "bytecode",
              "type": "bytes"
            },
            {
              "internalType": "uint256[]",
              "name": "constants",
              "type": "uint256[]"
            },
            {
              "internalType": "uint256[]",
              "name": "minOutputs",
              "type": "uint256[]"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "deployExpression",
          "outputs": [
            {
              "internalType": "contract IInterpreterV1",
              "name": "interpreter",
              "type": "address"
            },
            {
              "internalType": "contract IInterpreterStoreV1",
              "name": "store",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "expression",
              "type": "address"
            }
          ]
        }
      ],
      "devdoc": {
        "kind": "dev",
        "methods": {
          "deployExpression(bytes,uint256[],uint256[])": {
            "params": {
              "bytecode": "Bytecode verbatim. Exactly how the bytecode is structured is up to the deployer and interpreter. The deployer MUST NOT modify the bytecode in any way. The interpreter MUST NOT assume anything about the bytecode other than that it is valid according to the interpreter's integrity checks. It is assumed that the bytecode will be produced from a human friendly string via. `IParserV1.parse` but this is not required if the caller has some other means to prooduce valid bytecode.",
              "constants": "Constants verbatim. Constants are provided alongside sources rather than inline as it allows us to avoid variable length opcodes and can be more memory efficient if the same constant is referenced several times from the sources.",
              "minOutputs": "The first N sources on the state config are entrypoints to the expression where N is the length of the `minOutputs` array. Each item in the `minOutputs` array specifies the number of outputs that MUST be present on the final stack for an evaluation of each entrypoint. The minimum output for some entrypoint MAY be zero if the expectation is that the expression only applies checks and error logic. Non-entrypoint sources MUST NOT have a minimum outputs length specified."
            },
            "returns": {
              "expression": "The address of the deployed onchain expression. MUST be valid according to all integrity checks the deployer is aware of.",
              "interpreter": "The interpreter the deployer believes it is qualified to perform integrity checks on behalf of.",
              "store": "The interpreter store the deployer believes is compatible with the interpreter."
            }
          }
        },
        "version": 1
      },
      "userdoc": {
        "kind": "user",
        "methods": {
          "deployExpression(bytes,uint256[],uint256[])": {
            "notice": "Expressions are expected to be deployed onchain as immutable contract code with a first class address like any other contract or account. Technically this is optional in the sense that all the tools required to eval some expression and define all its opcodes are available as libraries. In practise there are enough advantages to deploying the sources directly onchain as contract data and loading them from the interpreter at eval: - Loading and storing binary data is gas efficient as immutable contract   data - Expressions need to be immutable between their deploy time integrity   check and runtime evaluation - Passing the address of an expression through calldata to an interpreter   is cheaper than passing an entire expression through calldata - Conceptually a very simple approach, even if implementations like   SSTORE2 are subtle under the hood The expression deployer MUST perform an integrity check of the source code before it puts the expression onchain at a known address. The integrity check MUST at a minimum (it is free to do additional static analysis) calculate the memory required to be allocated for the stack in total, and that no out of bounds memory reads/writes occur within this stack. A simple example of an invalid source would be one that pushes one value to the stack then attempts to pops two values, clearly we cannot remove more values than we added. The `IExpressionDeployerV2` MUST revert in the case of any integrity failure, all integrity checks MUST pass in order for the deployment to complete. Once the integrity check is complete the `IExpressionDeployerV2` MUST do any additional processing required by its paired interpreter. For example, the `IExpressionDeployerV2` MAY NEED to replace the indexed opcodes in the `ExpressionConfig` sources with real function pointers from the corresponding interpreter."
          }
        },
        "version": 1
      }
    },
    "settings": {
      "remappings": [
        "@prb/test/=lib/rain.interpreter/lib/prb-math/lib/prb-test/src/",
        "bitwise/=lib/rain.interpreter/src/lib/bitwise/",
        "bytecode/=lib/rain.interpreter/src/lib/bytecode/",
        "caller/=lib/rain.interpreter/src/lib/caller/",
        "compile/=lib/rain.interpreter/src/lib/compile/",
        "ds-test/=lib/forge-std/lib/ds-test/src/",
        "erc4626-tests/=lib/rain.interpreter/lib/openzeppelin-contracts/lib/erc4626-tests/",
        "eval/=lib/rain.interpreter/src/lib/eval/",
        "extern/=lib/rain.interpreter/src/lib/extern/",
        "forge-std/=lib/forge-std/src/",
        "integrity/=lib/rain.interpreter/src/lib/integrity/",
        "ns/=lib/rain.interpreter/src/lib/ns/",
        "op/=lib/rain.interpreter/src/lib/op/",
        "openzeppelin-contracts/=lib/rain.interpreter/lib/openzeppelin-contracts/",
        "openzeppelin/=lib/rain.interpreter/lib/openzeppelin-contracts/contracts/",
        "parse/=lib/rain.interpreter/src/lib/parse/",
        "prb-math/=lib/rain.interpreter/lib/prb-math/src/",
        "prb-test/=lib/rain.interpreter/lib/prb-math/lib/prb-test/src/",
        "rain.chainlink/=lib/rain.interpreter/lib/rain.chainlink/src/",
        "rain.datacontract/=lib/rain.interpreter/lib/rain.datacontract/src/",
        "rain.erc1820/=lib/rain.interpreter/lib/rain.erc1820/src/",
        "rain.interpreter/=lib/rain.interpreter/",
        "rain.lib.hash/=lib/rain.interpreter/lib/rain.lib.memkv/lib/rain.lib.hash/src/",
        "rain.lib.memkv/=lib/rain.interpreter/lib/rain.lib.memkv/src/",
        "rain.lib.typecast/=lib/rain.interpreter/lib/rain.lib.typecast/src/",
        "rain.math.fixedpoint/=lib/rain.interpreter/lib/rain.math.fixedpoint/src/",
        "rain.math.saturating/=lib/rain.interpreter/lib/rain.math.fixedpoint/lib/rain.math.saturating/src/",
        "rain.metadata/=lib/rain.interpreter/lib/rain.metadata/src/",
        "rain.solmem/=lib/rain.interpreter/lib/rain.solmem/src/",
        "sol.lib.binmaskflag/=lib/rain.interpreter/lib/sol.lib.binmaskflag/src/",
        "state/=lib/rain.interpreter/src/lib/state/",
        "uniswap/=lib/rain.interpreter/src/lib/uniswap/",
        "v2-core/=lib/rain.interpreter/lib/v2-core/contracts/",
        "v2-periphery/=lib/rain.interpreter/lib/v2-periphery/contracts/"
      ],
      "optimizer": {
        "enabled": true,
        "runs": 1000000
      },
      "metadata": {
        "bytecodeHash": "none",
        "appendCBOR": false
      },
      "compilationTarget": {
        "lib/rain.interpreter/src/interface/IExpressionDeployerV2.sol": "IExpressionDeployerV2"
      },
      "libraries": {}
    },
    "sources": {
      "lib/rain.interpreter/src/interface/IExpressionDeployerV2.sol": {
        "keccak256": "0x2b8e9d48c92c2c0e874fb4d073b0cb013fb36a830e16c68657bcf65ede7d8b16",
        "urls": [
          "bzz-raw://8de383c71dcaabb32fd9b91912bc7cba001a5a89c6f5de08b1a92447d0bebd12",
          "dweb:/ipfs/QmV1JV5ctH9cktJbYJxXvBNBePshfVB58voEUMCbgCtkhj"
        ],
        "license": "CAL"
      },
      "lib/rain.interpreter/src/interface/IInterpreterStoreV1.sol": {
        "keccak256": "0xbd9baa8cd30406576f876a76f1c08396561ba93131741af338f63e2414e20619",
        "urls": [
          "bzz-raw://30bb6f09d8b8f27f77e6c44591c4f2070286a91dad202043cf2351ae802e3df5",
          "dweb:/ipfs/QmRz5pfzf5w84iNmKaYYbqP8oQywzc5xbd3xzKmxgFyf9y"
        ],
        "license": "CAL"
      },
      "lib/rain.interpreter/src/interface/IInterpreterV1.sol": {
        "keccak256": "0xebde08ca2e1c25fc733e0bb8867598715f8ba79772f86db1c8960ad7d68a5293",
        "urls": [
          "bzz-raw://b93fb28a09aeea4afe7f0d4afc67354c0fa538e5a9b274b0c5f10ed1dd6b6b00",
          "dweb:/ipfs/QmatNhoHRSJ1ZvoCNo61YMt9jb1vvEkWy3mkcoPkB4FFA9"
        ],
        "license": "CAL"
      }
    },
    "version": 1
  },
  "ast": {
    "absolutePath": "lib/rain.interpreter/src/interface/IExpressionDeployerV2.sol",
    "id": 55298,
    "exportedSymbols": {
      "IERC1820_NAME_IEXPRESSION_DEPLOYER_V2": [
        55262
      ],
      "IExpressionDeployerV2": [
        55297
      ],
      "IInterpreterStoreV1": [
        55364
      ],
      "IInterpreterV1": [
        55414
      ]
    },
    "nodeType": "SourceUnit",
    "src": "32:6767:75",
    "nodes": [
      {
        "id": 55255,
        "nodeType": "PragmaDirective",
        "src": "32:24:75",
        "nodes": [],
        "literals": [
          "solidity",
          "^",
          "0.8",
          ".18"
        ]
      },
      {
        "id": 55257,
        "nodeType": "ImportDirective",
        "src": "58:62:75",
        "nodes": [],
        "absolutePath": "lib/rain.interpreter/src/interface/IInterpreterStoreV1.sol",
        "file": "./IInterpreterStoreV1.sol",
        "nameLocation": "-1:-1:-1",
        "scope": 55298,
        "sourceUnit": 55365,
        "symbolAliases": [
          {
            "foreign": {
              "id": 55256,
              "name": "IInterpreterStoreV1",
              "nodeType": "Identifier",
              "overloadedDeclarations": [],
              "referencedDeclaration": 55364,
              "src": "66:19:75",
              "typeDescriptions": {}
            },
            "nameLocation": "-1:-1:-1"
          }
        ],
        "unitAlias": ""
      },
      {
        "id": 55259,
        "nodeType": "ImportDirective",
        "src": "121:52:75",
        "nodes": [],
        "absolutePath": "lib/rain.interpreter/src/interface/IInterpreterV1.sol",
        "file": "./IInterpreterV1.sol",
        "nameLocation": "-1:-1:-1",
        "scope": 55298,
        "sourceUnit": 55415,
        "symbolAliases": [
          {
            "foreign": {
              "id": 55258,
              "name": "IInterpreterV1",
              "nodeType": "Identifier",
              "overloadedDeclarations": [],
              "referencedDeclaration": 55414,
              "src": "129:14:75",
              "typeDescriptions": {}
            },
            "nameLocation": "-1:-1:-1"
          }
        ],
        "unitAlias": ""
      },
      {
        "id": 55262,
        "nodeType": "VariableDeclaration",
        "src": "175:79:75",
        "nodes": [],
        "constant": true,
        "mutability": "constant",
        "name": "IERC1820_NAME_IEXPRESSION_DEPLOYER_V2",
        "nameLocation": "191:37:75",
        "scope": 55298,
        "stateVariable": false,
        "storageLocation": "default",
        "typeDescriptions": {
          "typeIdentifier": "t_string_memory_ptr",
          "typeString": "string"
        },
        "typeName": {
          "id": 55260,
          "name": "string",
          "nodeType": "ElementaryTypeName",
          "src": "175:6:75",
          "typeDescriptions": {
            "typeIdentifier": "t_string_storage_ptr",
            "typeString": "string"
          }
        },
        "value": {
          "hexValue": "4945787072657373696f6e4465706c6f7965725632",
          "id": 55261,
          "isConstant": false,
          "isLValue": false,
          "isPure": true,
          "kind": "string",
          "lValueRequested": false,
          "nodeType": "Literal",
          "src": "231:23:75",
          "typeDescriptions": {
            "typeIdentifier": "t_stringliteral_df2fb24711ac8a70ba0954aae92f0d032329580457cbb3882316f68164ab759c",
            "typeString": "literal_string \"IExpressionDeployerV2\""
          },
          "value": "IExpressionDeployerV2"
        },
        "visibility": "internal"
      },
      {
        "id": 55297,
        "nodeType": "ContractDefinition",
        "src": "2032:4766:75",
        "nodes": [
          {
            "id": 55276,
            "nodeType": "EventDefinition",
            "src": "2570:96:75",
            "nodes": [],
            "anonymous": false,
            "documentation": {
              "id": 55264,
              "nodeType": "StructuredDocumentation",
              "src": "2070:495:75",
              "text": "This is the literal InterpreterOpMeta bytes to be used offchain to make\n sense of the opcodes in this interpreter deployment, as a human. For\n formats like json that make heavy use of boilerplate, repetition and\n whitespace, some kind of compression is recommended.\n @param sender The `msg.sender` providing the op meta.\n @param meta The raw binary data of the construction meta. Maybe\n compressed data etc. and is intended for offchain consumption."
            },
            "eventSelector": "1788931a083e1bfada6cb062b5426ea97c7866b814b4d1173909e4018f2122f1",
            "name": "DISpair",
            "nameLocation": "2576:7:75",
            "parameters": {
              "id": 55275,
              "nodeType": "ParameterList",
              "parameters": [
                {
                  "constant": false,
                  "id": 55266,
                  "indexed": false,
                  "mutability": "mutable",
                  "name": "sender",
                  "nameLocation": "2592:6:75",
                  "nodeType": "VariableDeclaration",
                  "scope": 55276,
                  "src": "2584:14:75",
                  "stateVariable": false,
                  "storageLocation": "default",
                  "typeDescriptions": {
                    "typeIdentifier": "t_address",
                    "typeString": "address"
                  },
                  "typeName": {
                    "id": 55265,
                    "name": "address",
                    "nodeType": "ElementaryTypeName",
                    "src": "2584:7:75",
                    "stateMutability": "nonpayable",
                    "typeDescriptions": {
                      "typeIdentifier": "t_address",
                      "typeString": "address"
                    }
                  },
                  "visibility": "internal"
                },
                {
                  "constant": false,
                  "id": 55268,
                  "indexed": false,
                  "mutability": "mutable",
                  "name": "deployer",
                  "nameLocation": "2608:8:75",
                  "nodeType": "VariableDeclaration",
                  "scope": 55276,
                  "src": "2600:16:75",
                  "stateVariable": false,
                  "storageLocation": "default",
                  "typeDescriptions": {
                    "typeIdentifier": "t_address",
                    "typeString": "address"
                  },
                  "typeName": {
                    "id": 55267,
                    "name": "address",
                    "nodeType": "ElementaryTypeName",
                    "src": "2600:7:75",
                    "stateMutability": "nonpayable",
                    "typeDescriptions": {
                      "typeIdentifier": "t_address",
                      "typeString": "address"
                    }
                  },
                  "visibility": "internal"
                },
                {
                  "constant": false,
                  "id": 55270,
                  "indexed": false,
                  "mutability": "mutable",
                  "name": "interpreter",
                  "nameLocation": "2626:11:75",
                  "nodeType": "VariableDeclaration",
                  "scope": 55276,
                  "src": "2618:19:75",
                  "stateVariable": false,
                  "storageLocation": "default",
                  "typeDescriptions": {
                    "typeIdentifier": "t_address",
                    "typeString": "address"
                  },
                  "typeName": {
                    "id": 55269,
                    "name": "address",
                    "nodeType": "ElementaryTypeName",
                    "src": "2618:7:75",
                    "stateMutability": "nonpayable",
                    "typeDescriptions": {
                      "typeIdentifier": "t_address",
                      "typeString": "address"
                    }
                  },
                  "visibility": "internal"
                },
                {
                  "constant": false,
                  "id": 55272,
                  "indexed": false,
                  "mutability": "mutable",
                  "name": "store",
                  "nameLocation": "2647:5:75",
                  "nodeType": "VariableDeclaration",
                  "scope": 55276,
                  "src": "2639:13:75",
                  "stateVariable": false,
                  "storageLocation": "default",
                  "typeDescriptions": {
                    "typeIdentifier": "t_address",
                    "typeString": "address"
                  },
                  "typeName": {
                    "id": 55271,
                    "name": "address",
                    "nodeType": "ElementaryTypeName",
                    "src": "2639:7:75",
                    "stateMutability": "nonpayable",
                    "typeDescriptions": {
                      "typeIdentifier": "t_address",
                      "typeString": "address"
                    }
                  },
                  "visibility": "internal"
                },
                {
                  "constant": false,
                  "id": 55274,
                  "indexed": false,
                  "mutability": "mutable",
                  "name": "meta",
                  "nameLocation": "2660:4:75",
                  "nodeType": "VariableDeclaration",
                  "scope": 55276,
                  "src": "2654:10:75",
                  "stateVariable": false,
                  "storageLocation": "default",
                  "typeDescriptions": {
                    "typeIdentifier": "t_bytes_memory_ptr",
                    "typeString": "bytes"
                  },
                  "typeName": {
                    "id": 55273,
                    "name": "bytes",
                    "nodeType": "ElementaryTypeName",
                    "src": "2654:5:75",
                    "typeDescriptions": {
                      "typeIdentifier": "t_bytes_storage_ptr",
                      "typeString": "bytes"
                    }
                  },
                  "visibility": "internal"
                }
              ],
              "src": "2583:82:75"
            }
          },
          {
            "id": 55296,
            "nodeType": "FunctionDefinition",
            "src": "6575:221:75",
            "nodes": [],
            "documentation": {
              "id": 55277,
              "nodeType": "StructuredDocumentation",
              "src": "2672:3898:75",
              "text": "Expressions are expected to be deployed onchain as immutable contract\n code with a first class address like any other contract or account.\n Technically this is optional in the sense that all the tools required to\n eval some expression and define all its opcodes are available as\n libraries.\n In practise there are enough advantages to deploying the sources directly\n onchain as contract data and loading them from the interpreter at eval:\n - Loading and storing binary data is gas efficient as immutable contract\n   data\n - Expressions need to be immutable between their deploy time integrity\n   check and runtime evaluation\n - Passing the address of an expression through calldata to an interpreter\n   is cheaper than passing an entire expression through calldata\n - Conceptually a very simple approach, even if implementations like\n   SSTORE2 are subtle under the hood\n The expression deployer MUST perform an integrity check of the source\n code before it puts the expression onchain at a known address. The\n integrity check MUST at a minimum (it is free to do additional static\n analysis) calculate the memory required to be allocated for the stack in\n total, and that no out of bounds memory reads/writes occur within this\n stack. A simple example of an invalid source would be one that pushes one\n value to the stack then attempts to pops two values, clearly we cannot\n remove more values than we added. The `IExpressionDeployerV2` MUST revert\n in the case of any integrity failure, all integrity checks MUST pass in\n order for the deployment to complete.\n Once the integrity check is complete the `IExpressionDeployerV2` MUST do\n any additional processing required by its paired interpreter.\n For example, the `IExpressionDeployerV2` MAY NEED to replace the indexed\n opcodes in the `ExpressionConfig` sources with real function pointers\n from the corresponding interpreter.\n @param bytecode Bytecode verbatim. Exactly how the bytecode is structured\n is up to the deployer and interpreter. The deployer MUST NOT modify the\n bytecode in any way. The interpreter MUST NOT assume anything about the\n bytecode other than that it is valid according to the interpreter's\n integrity checks. It is assumed that the bytecode will be produced from\n a human friendly string via. `IParserV1.parse` but this is not required\n if the caller has some other means to prooduce valid bytecode.\n @param constants Constants verbatim. Constants are provided alongside\n sources rather than inline as it allows us to avoid variable length\n opcodes and can be more memory efficient if the same constant is\n referenced several times from the sources.\n @param minOutputs The first N sources on the state config are entrypoints\n to the expression where N is the length of the `minOutputs` array. Each\n item in the `minOutputs` array specifies the number of outputs that MUST\n be present on the final stack for an evaluation of each entrypoint. The\n minimum output for some entrypoint MAY be zero if the expectation is that\n the expression only applies checks and error logic. Non-entrypoint\n sources MUST NOT have a minimum outputs length specified.\n @return interpreter The interpreter the deployer believes it is qualified\n to perform integrity checks on behalf of.\n @return store The interpreter store the deployer believes is compatible\n with the interpreter.\n @return expression The address of the deployed onchain expression. MUST\n be valid according to all integrity checks the deployer is aware of."
            },
            "functionSelector": "31a66b65",
            "implemented": false,
            "kind": "function",
            "modifiers": [],
            "name": "deployExpression",
            "nameLocation": "6584:16:75",
            "parameters": {
              "id": 55286,
              "nodeType": "ParameterList",
              "parameters": [
                {
                  "constant": false,
                  "id": 55279,
                  "mutability": "mutable",
                  "name": "bytecode",
                  "nameLocation": "6616:8:75",
                  "nodeType": "VariableDeclaration",
                  "scope": 55296,
                  "src": "6601:23:75",
                  "stateVariable": false,
                  "storageLocation": "calldata",
                  "typeDescriptions": {
                    "typeIdentifier": "t_bytes_calldata_ptr",
                    "typeString": "bytes"
                  },
                  "typeName": {
                    "id": 55278,
                    "name": "bytes",
                    "nodeType": "ElementaryTypeName",
                    "src": "6601:5:75",
                    "typeDescriptions": {
                      "typeIdentifier": "t_bytes_storage_ptr",
                      "typeString": "bytes"
                    }
                  },
                  "visibility": "internal"
                },
                {
                  "constant": false,
                  "id": 55282,
                  "mutability": "mutable",
                  "name": "constants",
                  "nameLocation": "6645:9:75",
                  "nodeType": "VariableDeclaration",
                  "scope": 55296,
                  "src": "6626:28:75",
                  "stateVariable": false,
                  "storageLocation": "calldata",
                  "typeDescriptions": {
                    "typeIdentifier": "t_array$_t_uint256_$dyn_calldata_ptr",
                    "typeString": "uint256[]"
                  },
                  "typeName": {
                    "baseType": {
                      "id": 55280,
                      "name": "uint256",
                      "nodeType": "ElementaryTypeName",
                      "src": "6626:7:75",
                      "typeDescriptions": {
                        "typeIdentifier": "t_uint256",
                        "typeString": "uint256"
                      }
                    },
                    "id": 55281,
                    "nodeType": "ArrayTypeName",
                    "src": "6626:9:75",
                    "typeDescriptions": {
                      "typeIdentifier": "t_array$_t_uint256_$dyn_storage_ptr",
                      "typeString": "uint256[]"
                    }
                  },
                  "visibility": "internal"
                },
                {
                  "constant": false,
                  "id": 55285,
                  "mutability": "mutable",
                  "name": "minOutputs",
                  "nameLocation": "6675:10:75",
                  "nodeType": "VariableDeclaration",
                  "scope": 55296,
                  "src": "6656:29:75",
                  "stateVariable": false,
                  "storageLocation": "calldata",
                  "typeDescriptions": {
                    "typeIdentifier": "t_array$_t_uint256_$dyn_calldata_ptr",
                    "typeString": "uint256[]"
                  },
                  "typeName": {
                    "baseType": {
                      "id": 55283,
                      "name": "uint256",
                      "nodeType": "ElementaryTypeName",
                      "src": "6656:7:75",
                      "typeDescriptions": {
                        "typeIdentifier": "t_uint256",
                        "typeString": "uint256"
                      }
                    },
                    "id": 55284,
                    "nodeType": "ArrayTypeName",
                    "src": "6656:9:75",
                    "typeDescriptions": {
                      "typeIdentifier": "t_array$_t_uint256_$dyn_storage_ptr",
                      "typeString": "uint256[]"
                    }
                  },
                  "visibility": "internal"
                }
              ],
              "src": "6600:86:75"
            },
            "returnParameters": {
              "id": 55295,
              "nodeType": "ParameterList",
              "parameters": [
                {
                  "constant": false,
                  "id": 55289,
                  "mutability": "mutable",
                  "name": "interpreter",
                  "nameLocation": "6736:11:75",
                  "nodeType": "VariableDeclaration",
                  "scope": 55296,
                  "src": "6721:26:75",
                  "stateVariable": false,
                  "storageLocation": "default",
                  "typeDescriptions": {
                    "typeIdentifier": "t_contract$_IInterpreterV1_$55414",
                    "typeString": "contract IInterpreterV1"
                  },
                  "typeName": {
                    "id": 55288,
                    "nodeType": "UserDefinedTypeName",
                    "pathNode": {
                      "id": 55287,
                      "name": "IInterpreterV1",
                      "nameLocations": [
                        "6721:14:75"
                      ],
                      "nodeType": "IdentifierPath",
                      "referencedDeclaration": 55414,
                      "src": "6721:14:75"
                    },
                    "referencedDeclaration": 55414,
                    "src": "6721:14:75",
                    "typeDescriptions": {
                      "typeIdentifier": "t_contract$_IInterpreterV1_$55414",
                      "typeString": "contract IInterpreterV1"
                    }
                  },
                  "visibility": "internal"
                },
                {
                  "constant": false,
                  "id": 55292,
                  "mutability": "mutable",
                  "name": "store",
                  "nameLocation": "6769:5:75",
                  "nodeType": "VariableDeclaration",
                  "scope": 55296,
                  "src": "6749:25:75",
                  "stateVariable": false,
                  "storageLocation": "default",
                  "typeDescriptions": {
                    "typeIdentifier": "t_contract$_IInterpreterStoreV1_$55364",
                    "typeString": "contract IInterpreterStoreV1"
                  },
                  "typeName": {
                    "id": 55291,
                    "nodeType": "UserDefinedTypeName",
                    "pathNode": {
                      "id": 55290,
                      "name": "IInterpreterStoreV1",
                      "nameLocations": [
                        "6749:19:75"
                      ],
                      "nodeType": "IdentifierPath",
                      "referencedDeclaration": 55364,
                      "src": "6749:19:75"
                    },
                    "referencedDeclaration": 55364,
                    "src": "6749:19:75",
                    "typeDescriptions": {
                      "typeIdentifier": "t_contract$_IInterpreterStoreV1_$55364",
                      "typeString": "contract IInterpreterStoreV1"
                    }
                  },
                  "visibility": "internal"
                },
                {
                  "constant": false,
                  "id": 55294,
                  "mutability": "mutable",
                  "name": "expression",
                  "nameLocation": "6784:10:75",
                  "nodeType": "VariableDeclaration",
                  "scope": 55296,
                  "src": "6776:18:75",
                  "stateVariable": false,
                  "storageLocation": "default",
                  "typeDescriptions": {
                    "typeIdentifier": "t_address",
                    "typeString": "address"
                  },
                  "typeName": {
                    "id": 55293,
                    "name": "address",
                    "nodeType": "ElementaryTypeName",
                    "src": "6776:7:75",
                    "stateMutability": "nonpayable",
                    "typeDescriptions": {
                      "typeIdentifier": "t_address",
                      "typeString": "address"
                    }
                  },
                  "visibility": "internal"
                }
              ],
              "src": "6720:75:75"
            },
            "scope": 55297,
            "stateMutability": "nonpayable",
            "virtual": false,
            "visibility": "external"
          }
        ],
        "abstract": false,
        "baseContracts": [],
        "canonicalName": "IExpressionDeployerV2",
        "contractDependencies": [],
        "contractKind": "interface",
        "documentation": {
          "id": 55263,
          "nodeType": "StructuredDocumentation",
          "src": "257:1775:75",
          "text": "@title IExpressionDeployerV2\n @notice Companion to `IInterpreterV1` responsible for onchain static code\n analysis and deploying expressions. Each `IExpressionDeployerV2` is tightly\n coupled at the bytecode level to some interpreter that it knows how to\n analyse and deploy expressions for. The expression deployer can perform an\n integrity check \"dry run\" of candidate source code for the intepreter. The\n critical analysis/transformation includes:\n - Enforcement of no out of bounds memory reads/writes\n - Calculation of memory required to eval the stack with a single allocation\n - Replacing index based opcodes with absolute interpreter function pointers\n - Enforcement that all opcodes and operands used exist and are valid\n This analysis is highly sensitive to the specific implementation and position\n of all opcodes and function pointers as compiled into the interpreter. This\n is what makes the coupling between an interpreter and expression deployer\n so tight. Ideally all responsibilities would be handled by a single contract\n but this introduces code size issues quickly by roughly doubling the compiled\n logic of each opcode (half for the integrity check and half for evaluation).\n Interpreters MUST assume that expression deployers are malicious and fail\n gracefully if the integrity check is corrupt/bypassed and/or function\n pointers are incorrect, etc. i.e. the interpreter MUST always return a stack\n from `eval` in a read only way or error. I.e. it is the expression deployer's\n responsibility to do everything it can to prevent undefined behaviour in the\n interpreter, and the interpreter's responsibility to handle the expression\n deployer completely failing to do so."
        },
        "fullyImplemented": false,
        "linearizedBaseContracts": [
          55297
        ],
        "name": "IExpressionDeployerV2",
        "nameLocation": "2042:21:75",
        "scope": 55298,
        "usedErrors": []
      }
    ],
    "license": "CAL"
  },
  "id": 75
}