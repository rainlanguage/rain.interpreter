# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Build Environment

This project uses **Nix flakes** for development. All commands must be run inside `nix develop` or prefixed with `nix develop -c`. The `.envrc` auto-loads the nix shell via direnv.

### Prerequisites (run once per session, in order)

```bash
nix develop -c rainix-sol-prelude
nix develop -c rainix-rs-prelude
nix develop -c i9r-prelude
```

`i9r-prelude` generates metadata files needed by the Solidity build (runs `BuildAuthoringMeta.sol`, then `rain meta build` to produce CBOR-encoded deflated meta).

### Common Commands

```bash
# Solidity
nix develop -c rainix-sol-test          # forge test (all tests)
nix develop -c rainix-sol-static        # slither + forge fmt check
nix develop -c rainix-sol-artifacts     # build artifacts

# Run a single Solidity test
nix develop -c forge test --match-test "testFunctionName"
nix develop -c forge test --match-contract "ContractName"

# Rust
nix develop -c rainix-rs-test           # cargo test
nix develop -c rainix-rs-static         # cargo fmt --check + cargo clippy
nix develop -c test-wasm-build          # WASM compilation check

# Docs
nix develop -c forge doc -b             # Solidity docs
nix develop -c cargo doc                # Rust docs
```

### Build Pipeline

1. `BuildAuthoringMeta.sol` exports raw ABI-encoded authoring meta to `meta/`
2. `i9r-prelude` runs `rain meta build` to CBOR-encode and deflate the meta
3. `BuildPointers.sol` deploys contracts in local EVM, extracts function pointer tables, and writes `src/generated/*.pointers.sol`
4. `forge build` compiles everything using the generated pointers

The `src/generated/` directory contains build-time generated constants (bytecode hashes, function pointer tables, parse meta). These are regenerated by `BuildPointers.sol`.

## Architecture

### Four Core Components

1. **RainterpreterParser** (`src/concrete/RainterpreterParser.sol`) — Converts Rainlang text to bytecode. Uses bloom filter + fingerprint table for word lookup.

2. **RainterpreterStore** (`src/concrete/RainterpreterStore.sol`) — Sandboxed key-value storage. Namespaced by `msg.sender` + `StateNamespace`.

3. **Rainterpreter** (`src/concrete/Rainterpreter.sol`) — Stack-based evaluation runtime. Entry point: `eval4()`. Dispatches opcodes via function pointer tables.

4. **RainterpreterExpressionDeployer** (`src/concrete/RainterpreterExpressionDeployer.sol`) — Coordinates parse → integrity check → serialize. Enforces bytecode hash checks for the other three components. Implements `IParserV2`.

All four are deployed to deterministic addresses via Zoltu deployer. Addresses and code hashes are in `src/lib/deploy/LibInterpreterDeploy.sol`.

### Opcode System

Each opcode is a library in `src/lib/op/<category>/` with three functions:

- **`run(Operand, Pointer stackTop) → Pointer`** — Runtime execution
- **`integrity(IntegrityCheckState, Operand) → (inputs, outputs)`** — Pre-execution validation
- **Operand handler** — Parses operand bytes during parsing

All opcodes are registered in `src/lib/op/LibAllStandardOps.sol` which maintains four parallel arrays (authoring meta, operand handlers, integrity pointers, opcode pointers). The ordering must be consistent across all four arrays.

### Extern System

External contracts can extend the interpreter with additional opcodes. `src/concrete/extern/RainterpreterReferenceExtern.sol` is the reference implementation. Externs implement `IInterpreterExternV4` and have their own function pointer tables.

### Rust Crates (`crates/`)

- **cli** — CLI tool (`rain-i9r-cli`)
- **eval** — Evaluation runtime using REVM/foundry-evm
- **parser** — Rust parser implementation
- **dispair** — Dispatch pair utilities
- **bindings** — Alloy Solidity contract bindings
- **test_fixtures** — Shared test fixtures (deploys all contracts on local Anvil)

### Deployment

`script/Deploy.sol` uses the `DEPLOYMENT_SUITE` env var to select which component to deploy: `"parser"`, `"store"`, `"interpreter"`, or `"expression-deployer"`.

## Solidity Conventions

- **Solidity version**: exactly `0.8.25`, EVM target `cancun`
- **Optimizer**: enabled, 1000 runs
- **Fuzz runs**: 2048
- **License**: `CAL` (or `LicenseRef-DCL-1.0` for some files)
- Custom bytecode serialization is used instead of ABI encoding for gas efficiency
- Function pointer dispatch (no switch/if chains) for opcode routing
- Assembly blocks are used extensively and marked `memory-safe` where applicable

## Test Conventions

- Test files are in `test/` mirroring `src/` structure, suffixed `.t.sol`
- Base test contracts in `test/abstract/` — `OpTest` for opcodes, `ParseTest` for parser tests
- Use `opReferenceCheck` to test opcode runtime behavior against a reference implementation
- Rust test fixtures (`crates/test_fixtures/`) deploy all four contracts on a local Anvil instance

## Audit Review

When reviewing code for audit, read every file in full. Do not rely on grepping for patterns — systematic line-by-line review catches issues that keyword searches miss.

### Documentation
- Systematically enumerate every function in every contract and library, and verify each has NatSpec documentation
- Do not rely on scanning — explicitly list undocumented functions as findings
- All NatSpec must include `@param` and `@return` tags as relevant for functions, structs, errors, etc.
- After ensuring documentation exists, review it against the implementation for accuracy

### Security
- Check assembly blocks for memory safety: out-of-bounds reads/writes, incorrect pointer arithmetic, missing bounds checks
- Verify stack underflow/overflow protection in opcode `run` functions
- Check that integrity functions correctly declare inputs/outputs matching what `run` actually consumes/produces
- Look for reentrancy risks in opcodes that make external calls (ERC20, ERC721, extern)
- Verify namespace isolation in the store — `msg.sender` + `StateNamespace` must always scope storage access
- Check that bytecode hash verification in the expression deployer cannot be bypassed
- Verify function pointer tables cannot index out of bounds or be manipulated
- Look for unchecked arithmetic that could silently wrap
- Check that operand parsing rejects invalid operand values rather than silently misinterpreting them
- Verify that the eval loop cannot be made to jump to arbitrary code via crafted bytecode
- Check that context array access is bounds-checked
- Review extern dispatch for correct encoding/decoding of `ExternDispatchV2`
- Ensure all reverts use custom errors, not string messages (`revert("...")` is not allowed). Custom errors should be defined in `src/error/`

### Code Hygiene
- Review all commented-out code — each instance should be either reinstated or deleted, not left commented
- Ensure no build warnings from `forge build` or `cargo check`
- Identify leaky abstractions: internal details exposed through public interfaces, implementation concerns bleeding across module boundaries, or tight coupling between components that should be independent
- Check that all submodules sharing the same dependency are pinned to the same git commit
- Audit for style consistency across the repo — when similar code uses different patterns for the same thing, flag it

### Test Coverage
- Every function in every contract and library must have associated test cases
- Check that all error paths have corresponding test cases, preferably fuzzed
- Verify edge cases are covered: zero-length inputs, max-length inputs, off-by-one boundaries, odd/even length arrays where parity matters
- Ensure new error definitions added during audit have tests that trigger the revert
