# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Build Environment

This project uses **Nix flakes** for development. All commands must be run inside `nix develop` or prefixed with `nix develop -c`. The `.envrc` auto-loads the nix shell via direnv.

### Prerequisites (run once per session, in order)

```bash
nix develop -c rainix-sol-prelude
nix develop -c rainix-rs-prelude
nix develop -c i9r-prelude
```

`i9r-prelude` generates metadata files needed by the Solidity build (runs `BuildAuthoringMeta.sol`, then `rain meta build` to produce CBOR-encoded deflated meta).

### Common Commands

```bash
# Solidity
nix develop -c rainix-sol-test          # forge test (all tests)
nix develop -c rainix-sol-static        # slither + forge fmt check
nix develop -c rainix-sol-artifacts     # build artifacts

# Run a single Solidity test
nix develop -c forge test --match-test "testFunctionName"
nix develop -c forge test --match-contract "ContractName"

# Rust
nix develop -c rainix-rs-test           # cargo test
nix develop -c rainix-rs-static         # cargo fmt --check + cargo clippy
nix develop -c test-wasm-build          # WASM compilation check

# Docs
nix develop -c forge doc -b             # Solidity docs
nix develop -c cargo doc                # Rust docs
```

### Build Pipeline

1. `BuildAuthoringMeta.sol` exports raw ABI-encoded authoring meta to `meta/`
2. `i9r-prelude` runs `rain meta build` to CBOR-encode and deflate the meta
3. `BuildPointers.sol` deploys contracts in local EVM, extracts function pointer tables, and writes `src/generated/*.pointers.sol`
4. `forge build` compiles everything using the generated pointers

The `src/generated/` directory contains build-time generated constants (bytecode hashes, function pointer tables, parse meta). These are regenerated by `BuildPointers.sol`.

## Architecture

### Four Core Components

1. **RainterpreterParser** (`src/concrete/RainterpreterParser.sol`) — Converts Rainlang text to bytecode. Uses bloom filter + fingerprint table for word lookup.

2. **RainterpreterStore** (`src/concrete/RainterpreterStore.sol`) — Sandboxed key-value storage. Namespaced by `msg.sender` + `StateNamespace`.

3. **Rainterpreter** (`src/concrete/Rainterpreter.sol`) — Stack-based evaluation runtime. Entry point: `eval4()`. Dispatches opcodes via function pointer tables.

4. **RainterpreterExpressionDeployer** (`src/concrete/RainterpreterExpressionDeployer.sol`) — Coordinates parse → integrity check → serialize. Enforces bytecode hash checks for the other three components. Implements `IParserV2`.

All four are deployed to deterministic addresses via Zoltu deployer. Addresses and code hashes are in `src/lib/deploy/LibInterpreterDeploy.sol`.

### Opcode System

Each opcode is a library in `src/lib/op/<category>/` with three functions:

- **`run(Operand, Pointer stackTop) → Pointer`** — Runtime execution
- **`integrity(IntegrityCheckState, Operand) → (inputs, outputs)`** — Pre-execution validation
- **Operand handler** — Parses operand bytes during parsing

All opcodes are registered in `src/lib/op/LibAllStandardOps.sol` which maintains four parallel arrays (authoring meta, operand handlers, integrity pointers, opcode pointers). The ordering must be consistent across all four arrays.

### Extern System

External contracts can extend the interpreter with additional opcodes. `src/concrete/extern/RainterpreterReferenceExtern.sol` is the reference implementation. Externs implement `IInterpreterExternV4` and have their own function pointer tables.

### Rust Crates (`crates/`)

- **cli** — CLI tool (`rain-i9r-cli`)
- **eval** — Evaluation runtime using REVM/foundry-evm
- **parser** — Rust parser implementation
- **dispair** — Dispatch pair utilities
- **bindings** — Alloy Solidity contract bindings
- **test_fixtures** — Shared test fixtures (deploys all contracts on local Anvil)

### Deployment

`script/Deploy.sol` uses the `DEPLOYMENT_SUITE` env var to select which component to deploy: `"parser"`, `"store"`, `"interpreter"`, or `"expression-deployer"`.

## Solidity Conventions

- **Solidity version**: exactly `0.8.25`, EVM target `cancun`
- **Optimizer**: enabled, 1000 runs
- **Fuzz runs**: 2048
- **License**: `CAL` (or `LicenseRef-DCL-1.0` for some files)
- Custom bytecode serialization is used instead of ABI encoding for gas efficiency
- Function pointer dispatch (no switch/if chains) for opcode routing
- Assembly blocks are used extensively and marked `memory-safe` where applicable

## Test Conventions

- Test files are in `test/` mirroring `src/` structure, suffixed `.t.sol`
- Base test contracts in `test/abstract/` — `OpTest` for opcodes, `ParseTest` for parser tests
- Use `opReferenceCheck` to test opcode runtime behavior against a reference implementation
- Rust test fixtures (`crates/test_fixtures/`) deploy all four contracts on a local Anvil instance

## Audit Review

An audit consists of four separate passes, each run as independent agents. All four passes are mandatory. Do not combine them into a single pass.

Each pass will need multiple agents to cover the full codebase. When partitioning files across agents, ensure every source file is assigned to exactly one agent per pass. Prefer partitioning by directory (e.g., one agent for `src/lib/op/math/`, another for `src/lib/op/logic/`) over partitioning by concern, so that each agent can read its files deeply rather than skimming broadly.

Every pass requires reading every assigned file in full. Do not rely on grepping as a substitute for reading — systematic line-by-line review catches issues that keyword searches miss. Grepping is appropriate for cross-referencing (e.g., checking if an error name appears in test files) but not for understanding code.

Findings from all passes should be reported, not fixed. Fixes are a separate step after findings are reviewed.

### Pass 1: Security

Review for all security issues. The following are known areas of concern for this codebase, not an exhaustive list:

- Check assembly blocks for memory safety: out-of-bounds reads/writes, incorrect pointer arithmetic, missing bounds checks
- Verify stack underflow/overflow protection in opcode `run` functions
- Check that integrity functions correctly declare inputs/outputs matching what `run` actually consumes/produces
- Look for reentrancy risks in opcodes that make external calls (ERC20, ERC721, extern)
- Verify namespace isolation in the store — `msg.sender` + `StateNamespace` must always scope storage access
- Check that bytecode hash verification in the expression deployer cannot be bypassed
- Verify function pointer tables cannot index out of bounds or be manipulated
- Look for unchecked arithmetic that could silently wrap
- Check that operand parsing rejects invalid operand values rather than silently misinterpreting them
- Verify that the eval loop cannot be made to jump to arbitrary code via crafted bytecode
- Check that context array access is bounds-checked
- Review extern dispatch for correct encoding/decoding of `ExternDispatchV2`
- Ensure all reverts use custom errors, not string messages (`revert("...")` is not allowed). Custom errors should be defined in `src/error/`

### Pass 2: Test Coverage

For each source file, read both the source file and its corresponding test file(s). Test files are in `test/` mirroring `src/` structure, suffixed `.t.sol`. Some source files (especially error definitions in `src/error/`) are tested indirectly by test files elsewhere — grep for the error/function name across `test/` to find where coverage exists. Report all coverage gaps, including but not limited to:

- Source files with no corresponding test file
- Functions with no test exercising them
- Error/revert paths with no test triggering them (check every `revert` in source, every `error` in `src/error/`)
- Missing edge case coverage: zero-length inputs, max-length inputs, off-by-one boundaries, odd/even parity

### Pass 3: Documentation

Review all documentation for completeness and accuracy, including but not limited to:

- Systematically enumerate every function in every contract and library, and verify each has NatSpec documentation
- Explicitly list undocumented functions as findings
- All NatSpec must include `@param` and `@return` tags as relevant for functions, structs, errors, etc.
- After ensuring documentation exists, review it against the implementation for accuracy

### Pass 4: Code Quality

Review for maintainability, consistency, and good abstractions, including but not limited to:

- Audit for style consistency across the repo — when similar code uses different patterns for the same thing, flag it
- Identify leaky abstractions: internal details exposed through public interfaces, implementation concerns bleeding across module boundaries, or tight coupling between components that should be independent
- Review all commented-out code — each instance should be either reinstated or deleted, not left commented
- Ensure no build warnings from `forge build` or `cargo check`
- Check that all submodules sharing the same dependency are pinned to the same git commit
